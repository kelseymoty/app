import {
  Component,
  EventEmitter,
  Input,
  Output,
  ViewChild,
  ElementRef
} from "@angular/core";
import { STUDIES } from "./default-stimuli";
import { Study, Block, Trial, Coordinate } from "./stimuli";
import { ResponseService } from "../response/response.service";
import { Response } from "../response/response";

@Component({
  selector: "app-stimuli",
  templateUrl: "./stimuli.component.html",
  styleUrls: ["./stimuli.component.css"]
})
export class StimuliComponent {
  @Output() numberOfTrialsEvent = new EventEmitter<number>();
  @Input() age: number;

  // @ViewChild('thecontainer') imageContainerElement: ElementRef;
  @ViewChild("theimage") imageElement: ElementRef;

  study: Study = STUDIES;
  // TODO please abstract/move the process of stepping through blocks/trials so it's not done here..
  block: Block;
  blocks: Block[]; // the generated runlist for blocks
  curBlockIdx: number;
  // the current trial - this will be updated throughout the session
  trial: Trial;
  trials: Trial[]; // runlist for trials

  vid = 0;
  aud = 0;
  pic = 0;
  showPicture = false;
  introEnded = false;
  playAltAudio = false;
  chosenValue = null;
  responseService: ResponseService;
  numberOfTrials = 0;
  buttonResponse = 0;

  // for getCurrentVideo() and getCurrentAudio()
  currentVideo: string;
  currentAudio: string;
  currentImage: string;
  currentImageCoordinates: Coordinate[];
  currentButtons: string[];

  // autogenerated participant id - links together their responses
  participant: number = Date.now();

  // initialize: choose the study, condition, and first trial
  constructor(responseService: ResponseService) {
    this.responseService = responseService;
    // init/refresh db connection
    // TODO find better way to set/init study/DB name? injection?
    this.responseService.getDBConnection(this.study.name);

    this.genBlockRunList();
    this.setBlock(0);
    this.genTrialRunList();
    this.setTrial(0);

    this.introEnded = true;
    console.log(this.introEnded);
  }

  setBlock(idx) {
    // if (typeof this.block != "undefined") {
    //   return; // condition already set- one per session
    // }
    // const condition = this.study.conditions[1]; // this.study.conditions[Math.floor(Math.random() * this.study.conditions.length)];
    const block = this.blocks[idx];
    // TODO proper error handling/logging. debug setting. error messages/checks each call. (if can't set idx, say why)
    const blockCopy = JSON.parse(JSON.stringify(block));
    // set class property
    this.block = blockCopy;
    this.curBlockIdx = idx;
  }

  nextBlock() {
    // incrementation of blocks/trials/whatever can be pulled out into module - all done the same way
    const length = this.blocks.length;

    if (this.curBlockIdx == length - 1) {
      // we're done - call done() (not implemented yet)
      return this.done();
    }

    this.setBlock(this.curBlockIdx + 1); // TODO once the basics of this are worked out, go through test-driven implementation
    this.genTrialRunList();
    this.setTrial(0);
  }

  done() {
    return;
  }

  videoEnded() {
    const nextVideo = this.nextVideo();
    console.log(nextVideo, "result is this");

    if (!nextVideo && typeof this.trial.picture === "undefined") {
      console.log("moving to next trial when no pictures");
      this.nextTrial();
    } else if (!nextVideo) {
      this.showPicture = true;
    }

    console.log(
      nextVideo,
      this.trial.picture,
      "this is the stuff in videoEnded"
    );
  }

  // return location of current trial in conditions' list of trials
  // TODO there's a built-in javascript function for this, use that instead
  getTrialIndexById(id): number {
    let result: number;

    // this.study.block.forEach(cond => {
    this.block.trials.forEach((trial, index) => {
      if (trial.id == id) {
        result = index;
      }
    });
    // });
    return result;
  }

  genTrialRunList() {
    // create trial playlist
    // if current trial is marked primary, add it to list
    // so this is done earlier. need to generate at beginning - right now we just run throguh
    // so create genPlayList function, and do this in there - all this should be unchanged, the random/etc behavior is transparent

    // set trial randomly
    const length = this.block.trials.length;
    let final: Trial[] = [];

    if (this.block.randomize) {
      // const blockCopy = JSON.parse(JSON.stringify(this.block));
      // check for primary/ordered item(s)

      const temp: Trial[] = [];

      for (const item of this.block.trials) {
        if (item.primary) {
          // blockCopy.pop()
          final.push(item);
        } else {
          temp.push(item);
        }
      }

      this.shuffleList(temp);
      // TODO test this vs final.push.apply(final, temp)
      final = final.concat(temp);
    } else {
      final = this.block.trials;
    }

    this.trials = final;
  }

  // non-op currently
  genBlockRunList() {
    this.blocks = this.study.blocks;
  }

  // copied from https://www.w3resource.com/javascript-exercises/javascript-array-exercise-17.php
  // Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
  shuffleList(list) {
    let ctr = list.length,
      temp,
      index;

    // While there are elements in the array
    while (ctr > 0) {
      // Pick a random index
      index = Math.floor(Math.random() * ctr);
      // Decrease ctr by 1
      ctr--;
      // And swap the last element with it
      temp = list[ctr];
      list[ctr] = list[index];
      list[index] = temp;
    }

    return list;
  }

  setTrial(idx) {
    this.trial = this.trials[idx];
  }

  nextVideo(): boolean {
    if (this.vid == this.trial.movie.length - 1) {
      console.log("no more videos", this.trial.movie);
      return false;
    }

    console.log("return another video");
    this.vid++;
    return true;
  }

  // TODO if person wants to play same video twice in row, Angular does nothing.
  // would need to build another function to handle playing
  getCurrentVideo() {
    console.log("before", this.currentVideo);
    console.log("showPicture", this.showPicture);
    const video = this.trial.movie[this.vid];
    if (video != this.currentVideo) {
      // keep them in sync
      this.currentVideo = video;
    }
    console.log("after", this.currentVideo);
    return video;
  }

  getCurrentButtons() {
    if (this.trial.button) {
      // keep them in sync
      this.currentButtons = this.trial.button;
      console.log(this.currentButtons);
      return this.currentButtons;
    }

    return null;
  }

  audioEnded(alt) {
    if (alt) {
      this.playAltAudio = false;
    }
  }

  getCurrentAudio(audioType) {
    let audio = this.trial.sound[this.aud];

    if (audioType == 0) {
      audio = this.trial.sound1[this.aud];
    }

    if (audioType == 2) {
      audio = this.trial.sound[this.aud + 1];
    }

    if (audio != this.currentAudio) {
      this.currentAudio = audio;
    }

    return audio;
  }

  nextAudio(): boolean {
    if (this.aud == this.trial.sound.length - 1) {
      return false;
    }

    this.aud++;
    return true;
  }

  getCurrentImage() {
    const image = this.trial.picture.picture[this.pic];
    if (image != this.currentImage) {
      this.currentImage = image;
    }

    this.getCurrentButtons();
    return image;
  }

  getCurrentImageCoordinates() {
    // if (typeof this.imageElement == 'undefined') {
    //   return;
    // }
    let coords = this.trial.picture.coordinate;

    if (!coords) {
      this.currentImageCoordinates = null;
      return null;
    }

    if (coords != this.currentImageCoordinates) {
      coords = coords.map(val => {
        let res = val.coordinate.split(",");
        res = res.map(v => {
          return String(Math.floor(Number(v) * 0.86)); // .95 if on surface book
        });

        return {
          coordinate: res.join(","),
          disabled: val.disabled
        };
      });

      this.currentImageCoordinates = coords;
      return coords;
    }
  }

  getCssCoordinates(coords) {
    let res = coords.split(",");
    res = res.map(val => {
      val = val - 80; // todo make the box size set somewhere and use that var
      if (val < 0) {
        val = 0;
      }

      return val + "px";
    });

    return res;
  }

  blockedCoordinates() {
    if (this.currentImageCoordinates) {
      return this.currentImageCoordinates.filter(value => {
        return value.disabled; // send back only the disabled coordinate areas
      });
    }

    return null;
  }

  setValue(value) {
    this.buttonResponse = value;
    console.log(this.buttonResponse, "is the button response");
    this.nextTrial(this.buttonResponse);
  }

  trialsCompleted() {
    this.numberOfTrials++;
    this.numberOfTrialsEvent.emit(this.numberOfTrials);
  }

  // derived from https://stackoverflow.com/questions/3820381/need-a-basename-function-in-javascript/3820412#3820412
  // (stackoverflow code licensed as MIT)
  basename(str) {
    let base = String(str).substring(str.lastIndexOf("/") + 1);
    if (base.lastIndexOf(".") != -1) {
      base = base.substring(0, base.lastIndexOf("."));
    }
    return base;
  }

  // stores value sent to it by image (click)
  // removes finished trial from list, for next selection
  nextTrial(value?) {
    this.trialsCompleted();
    this.vid = 0;
    this.aud = 0;
    this.pic = 0;
    this.showPicture = false;
    console.log("after resetting lots of things in next trial()");

    if (value) {
      this.sendResponse(value);
    }
    console.log(this.introEnded, "what introEnded is set at ");

    const length = this.trials.length;
    // get index of the current trial in block list
    const index = this.getTrialIndexById(this.trial.id);
    // remove run trial from list of available
    // this.block.trials.splice(index, 1);

    if (index == length - 1) {
      // trials in block done, end function call and go to next block
      return this.nextBlock();
    }

    this.setTrial(index + 1);
    console.log("trial now =", this.trial);
  }

  sendResponse(value) {
    const response = new Response();
    response.data.participant = this.participant;
    response.data.age = this.age; // todo fill in TODO
    response.data.study = this.study.name;
    response.data.block = this.block.id;
    response.data.trial = this.trial.id;
    response.data.response.push(value + 1);

    // this.currentImageCoordinates[value].disabled = true;
    this.responseService.setResponse(response);
  }
}
